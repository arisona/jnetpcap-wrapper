<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (19) on Mon Oct 24 19:11:48 EDT 2022 -->
<title>Scratch (jNetPcap Binding 2.0.0-preview.1 API)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="dc.created" content="2022-10-24">
<meta name="description" content="declaration: module: org.jnetpcap, package: org.jnetpcap, class: Scratch">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-3.6.0.min.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var pathtoroot = "../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span></button>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../module-summary.html">Module</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/Scratch.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html#class">Help</a></li>
</ul>
<ul class="sub-nav-list-small">
<li>
<p>Summary:</p>
<ul>
<li>Nested</li>
<li>Field</li>
<li><a href="#constructor-summary">Constr</a></li>
<li><a href="#method-summary">Method</a></li>
</ul>
</li>
<li>
<p>Detail:</p>
<ul>
<li>Field</li>
<li><a href="#constructor-detail">Constr</a></li>
<li>Method</li>
</ul>
</li>
</ul>
</div>
<div class="sub-nav">
<div id="navbar-sub-list">
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor-summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor-detail">Constr</a>&nbsp;|&nbsp;</li>
<li>Method</li>
</ul>
</div>
<div class="nav-list-search"><a href="../../../search.html">SEARCH</a>
<input type="text" id="search-input" disabled placeholder="Search">
<input type="reset" id="reset-button" disabled value="reset">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="module-label-in-type">Module</span>&nbsp;<a href="../../module-summary.html">org.jnetpcap</a></div>
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">org.jnetpcap</a></div>
<h1 title="Class Scratch" class="title">Class Scratch</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">java.lang.Object</a>
<div class="inheritance">org.jnetpcap.Scratch</div>
</div>
<section class="class-description" id="class-description">
<hr>
<div class="type-signature"><span class="modifiers">public class </span><span class="element-name type-name-label">Scratch</span>
<span class="extends-implements">extends <a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></span></div>
<div class="block">Native <em>Pcap</em> wrapper API and implementation on *Unix and Microsoft
 Windows platforms.
 <h1>Description</h1>
 <p>
 The Packet Capture library provides a high level interface to packet capture
 systems. All packets on the network, even those destined for other hosts, are
 accessible through this mechanism. It also supports saving captured packets
 to a ``savefile'', and reading packets from a ``savefile''.
 </p>
 
 <h1>Opening a capture handle for reading</h1>
 <p>
 To open a handle for a live capture, given the name of the network or other
 interface on which the capture should be done, call
 <a href="Pcap.html#create(org.jnetpcap.PcapIf)"><code>Pcap.create(PcapIf)</code></a>, set the appropriate options on the
 handle, and then activate it with <a href="Pcap.html#activate()"><code>Pcap.activate()</code></a>. If
 <a href="Pcap.html#activate()"><code>Pcap.activate()</code></a> fails, the handle should be closed with
 <a href="Pcap.html#close()"><code>Pcap.close()</code></a>.
 </p>
 
 <p>
 To obtain a list of devices that can be opened for a live capture, call
 <a href="Pcap.html#findAllDevs()"><code>Pcap.findAllDevs()</code></a>; the list is automatically freed by
 <em>jNePcap</em>. <a href="Pcap.html#lookupDev()"><code>Pcap.lookupDev()</code></a> will return the first
 device on that list that is not a ``loopback`` network interface.
 </p>
 
 <p>
 To open a handle for a ``savefile'' from which to read packets, given the
 pathname of the ``savefile'', call
 <a href="Pcap.html#openOffline(java.io.File)"><code>Pcap.openOffline(File file)</code></a>; to set up a handle for a
 ``savefile'', given a FILE * referring to a file already opened for reading,
 call <a href="Pcap.html#openOffline(java.io.File)"><code>Pcap.openOffline(File file)</code></a>.
 </p>
 
 <p>
 In order to get a ``fake'' <code>Pcap</code> for use in routines that require a
 <code>Pcap</code> as an argument, such as routines to open a ``savefile'' for
 writing and to compile a filter expression, call
 <a href="Pcap.html#openDead(org.jnetpcap.constant.PcapDlt,int)"><code>Pcap.openDead(PcapDlt, int)</code></a>.
 </p>
 
 <p>
 <a href="Pcap.html#create(org.jnetpcap.PcapIf)"><code>Pcap.create(org.jnetpcap.PcapIf)</code></a>,
 <a href="Pcap.html#openOffline(java.io.File)"><code>Pcap.openOffline(File file)</code></a>, and
 <a href="Pcap.html#openDead(org.jnetpcap.constant.PcapDlt,int)"><code>Pcap.openDead(PcapDlt, int)</code></a> return a reference to a
 <code>Pcap</code>, which is the handle used for reading packets from the capture
 stream or the ``savefile'', and for finding out information about the capture
 stream or ``savefile''. To close a handle, use
 <a href="Pcap.html#close()"><code>Pcap.close()</code></a>.
 </p>
 
 <p>
 The options that can be set on a capture handle include
 <dl>
 <dt>snapshot length</dt>
 <dd>
 <p>
 If, when capturing, you capture the entire contents of the packet, that
 requires more CPU time to copy the packet to your application, more disk and
 possibly network bandwidth to write the packet data to a file, and more disk
 space to save the packet. If you don't need the entire contents of the packet
 - for example, if you are only interested in the TCP headers of packets - you
 can set the "snapshot length" for the capture to an appropriate value. If the
 snapshot length is set to snaplen, and snaplen is less than the size of a
 packet that is captured, only the first snaplen bytes of that packet will be
 captured and provided as packet data.
 </p>
 <p>
 A snapshot length of 65535 should be sufficient, on most if not all networks,
 to capture all the data available from the packet.
 </p>
 <p>
 The snapshot length is set with <a href="Pcap.html#setSnaplen(int)"><code>Pcap.setSnaplen(int)</code></a>.
 </p>
 </dd>
 <dt>promiscuous mode</dt>
 <dd>
 <p>
 On broadcast LANs such as Ethernet, if the network isn't switched, or if the
 adapter is connected to a "mirror port" on a switch to which all packets
 passing through the switch are sent, a network adapter receives all packets
 on the LAN, including unicast or multicast packets not sent to a network
 address that the network adapter isn't configured to recognize.
 </p>
 <p>
 Normally, the adapter will discard those packets; however, many network
 adapters support "promiscuous mode", which is a mode in which all packets,
 even if they are not sent to an address that the adapter recognizes, are
 provided to the host. This is useful for passively capturing traffic between
 two or more other hosts for analysis.
 </p>
 <p>
 Note that even if an application does not set promiscuous mode, the adapter
 could well be in promiscuous mode for some other reason.
 </p>
 <p>
 For now, this doesn't work on the "any" device; if an argument of "any" or
 NULL is supplied, the setting of promiscuous mode is ignored.
 </p>
 <p>
 Promiscuous mode is set with <a href="Pcap.html#setPromisc(boolean)"><code>Pcap.setPromisc(boolean)</code></a>.
 </p>
 </dd>
 <dt>monitor mode</dt>
 <dd>
 <p>
 On IEEE 802.11 wireless LANs, even if an adapter is in promiscuous mode, it
 will supply to the host only frames for the network with which it's
 associated. It might also supply only data frames, not management or control
 frames, and might not provide the 802.11 header or radio information
 pseudo-header for those frames.
 </p>
 <p>
 In "monitor mode", sometimes also called "rfmon mode" (for "Radio Frequency
 MONitor"), the adapter will supply all frames that it receives, with 802.11
 headers, and might supply a pseudo-header with radio information about the
 frame as well.
 </p>
 <p>
 Note that in monitor mode the adapter might disassociate from the network
 with which it's associated, so that you will not be able to use any wireless
 networks with that adapter. This could prevent accessing files on a network
 server, or resolving host names or network addresses, if you are capturing in
 monitor mode and are not connected to another network with another adapter.
 </p>
 <p>
 Monitor mode is set with <a href="Pcap.html#setRfmon(boolean)"><code>Pcap.setRfmon(boolean)</code></a>, and
 <a href="Pcap.html#canSetRfmon()"><code>Pcap.canSetRfmon()</code></a> can be used to determine whether an
 adapter can be put into monitor mode.
 </p>
 </dd>
 <dt></dt>
 <dd>
 <p>
 If, when capturing, packets are delivered as soon as they arrive, the
 application capturing the packets will be woken up for each packet as it
 arrives, and might have to make one or more calls to the operating system to
 fetch each packet.
 </p>
 <p>
 If, instead, packets are not delivered as soon as they arrive, but are
 delivered after a short delay (called a "packet buffer timeout"), more than
 one packet can be accumulated before the packets are delivered, so that a
 single wakeup would be done for multiple packets, and each set of calls made
 to the operating system would supply multiple packets, rather than a single
 packet. This reduces the per-packet CPU overhead if packets are arriving at a
 high rate, increasing the number of packets per second that can be captured.
 </p>
 <p>
 The packet buffer timeout is required so that an application won't wait for
 the operating system's capture buffer to fill up before packets are
 delivered; if packets are arriving slowly, that wait could take an
 arbitrarily long period of time.
 </p>
 <p>
 Not all platforms support a packet buffer timeout; on platforms that don't,
 the packet buffer timeout is ignored. A zero value for the timeout, on
 platforms that support a packet buffer timeout, will cause a read to wait
 forever to allow enough packets to arrive, with no timeout. A negative value
 is invalid; the result of setting the timeout to a negative value is
 unpredictable.
 </p>
 <p>
 <b>NOTE:</b> the packet buffer timeout cannot be used to cause calls that
 read packets to return within a limited period of time, because, on some
 platforms, the packet buffer timeout isn't supported, and, on other
 platforms, the timer doesn't start until at least one packet arrives. This
 means that the packet buffer timeout should <b>NOT</b> be used, for example,
 in an interactive application to allow the packet capture loop to ``poll''
 for user input periodically, as there's no guarantee that a call reading
 packets will return after the timeout expires even if no packets have
 arrived.
 </p>
 <p>
 The packet buffer timeout is set with <a href="Pcap.html#setTimeout(int)"><code>Pcap.setTimeout(int)</code></a>.
 </p>
 </dd>
 <dt>immediate mode</dt>
 <dd>
 <p>
 In immediate mode, packets are always delivered as soon as they arrive, with
 no buffering. Immediate mode is set with pcap_set_immediate_mode().
 </p>
 </dd>
 <dt>buffer size</dt>
 <dd>
 <p>
 Packets that arrive for a capture are stored in a buffer, so that they do not
 have to be read by the application as soon as they arrive. On some platforms,
 the buffer's size can be set; a size that's too small could mean that, if too
 many packets are being captured and the snapshot length doesn't limit the
 amount of data that's buffered, packets could be dropped if the buffer fills
 up before the application can read packets from it, while a size that's too
 large could use more non-pageable operating system memory than is necessary
 to prevent packets from being dropped.
 </p>
 <p>
 The buffer size is set with <a href="Pcap.html#setBufferSize(int)"><code>Pcap.setBufferSize(int)</code></a>.
 </p>
 </dd>
 <dt>timestamp type</dt>
 <dd>
 <p>
 On some platforms, the time stamp given to packets on live captures can come
 from different sources that can have different resolutions or that can have
 different relationships to the time values for the current time supplied by
 routines on the native operating system.
 </p>
 <p>
 The time stamp type is set with
 <a href="Pcap.html#setTstampType(org.jnetpcap.constant.PcapTstampType)"><code>Pcap.setTstampType(PcapTstampType)</code></a>.
 </p>
 </dd>
 </dl>
 </p></div>
<dl class="notes">
<dt>Author:</dt>
<dd>Mark Bednarczyk, Sly Technologies Inc., repos@slytechs.com
         <argLine>-Djava.library.path=/usr/lib/x86_64-linux-gnu
         --enable-preview --enable-native-access=org.jnet.pcap</argLine></dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li>
<section class="constructor-summary" id="constructor-summary">
<h2>Constructor Summary</h2>
<div class="caption"><span>Constructors</span></div>
<div class="summary-table two-column-summary">
<div class="table-header col-first">Constructor</div>
<div class="table-header col-last">Description</div>
<div class="col-constructor-name even-row-color"><code><a href="#%3Cinit%3E()" class="member-name-link">Scratch</a>()</code></div>
<div class="col-last even-row-color">&nbsp;</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.lang.Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Object.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Object.html#toString()" title="class or interface in java.lang" class="external-link">toString</a>, <a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li>
<section class="constructor-details" id="constructor-detail">
<h2>Constructor Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="&lt;init&gt;()">
<h3>Scratch</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="element-name">Scratch</span>()</div>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<hr>
<p class="legal-copy"><small>Copyright &#169; 2022 <a href="http://slytechs.com">Sly Technologies Inc</a>. All rights reserved.</small></p>
</footer>
</div>
</div>
</body>
</html>
